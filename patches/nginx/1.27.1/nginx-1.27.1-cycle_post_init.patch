--- nginx-1.27.1/src/core/nginx.c	2022-02-21 11:34:09.012837824 +0800
+++ nginx-1.27.1-patched/src/core/nginx.c	2022-02-21 11:33:57.181749749 +0800
@@ -364,6 +355,10 @@
         return 1;
     }
 
+    if (ngx_cycle_post_init(cycle) != NGX_OK) {
+        return 1;
+    }
+
     if (!ngx_inherited && ccf->daemon) {
         if (ngx_daemon(cycle->log) != NGX_OK) {
             return 1;
--- nginx-1.27.1/src/core/ngx_cycle.c	2022-02-21 11:34:09.013837831 +0800
+++ nginx-1.27.1-patched/src/core/ngx_cycle.c	2022-02-21 11:33:57.181749749 +0800
@@ -230,6 +230,14 @@
     }
 
 
+    cycle->post_init_handlers = ngx_pcalloc(pool, ngx_max_module *
+                                            sizeof(ngx_post_init_pt *));
+    if (cycle->post_init_handlers == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+
     for (i = 0; cycle->modules[i]; i++) {
         if (cycle->modules[i]->type != NGX_CORE_MODULE) {
             continue;
@@ -1476,3 +1484,44 @@
         c[i].read->handler(c[i].read);
     }
 }
+
+
+ngx_int_t
+ngx_cycle_set_post_init(ngx_cycle_t *cycle, ngx_module_t *module,
+        ngx_post_init_pt post_init)
+{
+    if (cycle->post_init_handlers[module->index]) {
+        ngx_log_error(NGX_LOG_ERR, cycle->log, 0,
+                "%s's post_init hook already exists", module->name);
+        return NGX_ERROR;
+    }
+
+    cycle->post_init_handlers[module->index] = post_init;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_cycle_post_init(ngx_cycle_t *cycle) {
+    ngx_int_t rc;
+    ngx_uint_t i;
+    ngx_post_init_pt post_init;
+
+    for (i = 0; cycle->modules[i]; i++) {
+        post_init = cycle->post_init_handlers[i];
+
+        if (post_init) {
+            rc = post_init(cycle);
+
+            if (rc != NGX_OK) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                              "%s's post_init hook exit with non-zero code: %d",
+                              cycle->modules[i]->name, rc);
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    return NGX_OK;
+}
--- nginx-1.27.1/src/core/ngx_cycle.h	2022-02-21 11:34:09.013837831 +0800
+++ nginx-1.27.1-patched/src/core/ngx_cycle.h	2022-02-21 11:33:57.181749749 +0800
@@ -34,6 +34,7 @@
 typedef ngx_int_t (*ngx_shm_zone_init_pt) (ngx_shm_zone_t *zone, void *data);
 typedef ngx_int_t (*ngx_log_intercept_pt) (ngx_log_t *log, ngx_uint_t level,
     u_char *buf, size_t len);
+typedef ngx_int_t (*ngx_post_init_pt) (ngx_cycle_t *cycle);
 
 struct ngx_shm_zone_s {
     void                     *data;
@@ -100,6 +101,7 @@
     ngx_log_intercept_pt      intercept_error_log_handler;
     void                     *intercept_error_log_data;
     unsigned                  entered_logger;    /* :1 */
+    ngx_post_init_pt         *post_init_handlers;
 };
 
 
@@ -155,6 +157,9 @@
 ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,
     size_t size, void *tag);
 void ngx_set_shutdown_timer(ngx_cycle_t *cycle);
+ngx_int_t ngx_cycle_set_post_init(ngx_cycle_t *cycle,
+        ngx_module_t *module, ngx_post_init_pt handler);
+ngx_int_t ngx_cycle_post_init(ngx_cycle_t *cycle);
 
 
 extern volatile ngx_cycle_t  *ngx_cycle;
--- nginx-1.27.1/src/os/unix/ngx_process_cycle.c	2022-02-25 22:14:50.124640530 +0800
+++ nginx-1.27.1-patched/src/os/unix/ngx_process_cycle.c	2022-02-25 22:03:09.584244984 +0800
@@ -250,6 +250,9 @@
             ngx_cycle = cycle;
             ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,
                                                    ngx_core_module);
+            if (ngx_cycle_post_init(cycle) != NGX_OK) {
+                continue;
+            }
             ngx_start_worker_processes(cycle, ccf->worker_processes,
                                        NGX_PROCESS_JUST_RESPAWN);
             ngx_start_cache_manager_processes(cycle, 1);
